r"""
Laplace equation in 1D with a variable coefficient.

Because the mesh is trivial in 1D, it is generated by :func:`mesh_hook()`, and
registered using :class:`UserMeshIO <sfepy.discrete.fem.meshio.UserMeshIO>`.

Find :math:`t` such that:

.. math::
    \int_{\Omega} c(x) \tdiff{s}{x} \tdiff{t}{x}
    = 0
    \;, \quad \forall s \;,

where the coefficient :math:`c(x) = 0.1 + \sin(2 \pi x)^2` is computed in
:func:`get_coef()`.

View the results using::

  sfepy-view laplace_1d.vtk -f t:wt 1:vw
"""
from __future__ import absolute_import
import numpy as nm
from sfepy.discrete.fem import Mesh
from sfepy.discrete.fem.meshio import UserMeshIO
import csv

d_ins = 0.1       # Insulation thickness [m]
dx = 0.005        # Cell size [m]
n_el = int(d_ins / dx)  # Number of elements
nodes = n_el + 1        # Number of nodes

def mesh_hook(mesh, mode):
    """Generate the 1D mesh."""
    if mode == 'read':
        coors = nm.linspace(0.0, d_ins, nodes).reshape((nodes, 1))
        conn = nm.arange(nodes, dtype=nm.int32).repeat(2)[1:-1].reshape((-1, 2))
        mat_ids = nm.zeros(nodes - 1, dtype=nm.int32)
        descs = ['1_2']

        mesh = Mesh.from_data('heat_1d', coors, None,
                             [conn], [mat_ids], descs)
        return mesh
    elif mode == 'write':
        pass

    elif mode == 'write':
        pass

def get_coef(ts, coors, mode=None, **kwargs):
    if mode == 'qp':
        x = coors[:, 0]

        val = 0.1 + nm.sin(2 * nm.pi * x)**2
        val.shape = (coors.shape[0], 1, 1)

        return {'val' : val}

filename_mesh = UserMeshIO(mesh_hook)

def read_temp_and_hcoeff_from_csv(filename="t_o_and_h_o.csv"):
    """Read temperature and heat transfer coefficient data from CSV file."""
    t_o, h_o = [], []
    with open(filename, 'r') as csvfile:
        csvreader = csv.reader(csvfile)
        for row in csvreader:
            if len(row) >= 2:
                t_o.append(float(row[0].strip()))
                h_o.append(float(row[1].strip()))
    return t_o, h_o

t_o, h_o = read_temp_and_hcoeff_from_csv()
nr_hour = len(t_o)  # Number of hours
h_i = 99.75  # W/m2K (inner heat transfer coefficient)

def get_bc_values(ts, coor, mode=None, region_name=None, **kwargs):
    """
    Time-dependent boundary condition values.
    """
    if mode != 'qp': return {}
    
    hour = ts.time / 3600  # Current hour
    hour_idx = min(int(hour), nr_hour - 1)  # Index for current hour
    
    nqp = coor.shape[0]
    val = nm.zeros((nqp, 1, 2), dtype=nm.float64)  # h and T_inf
    
    if region_name == 'Gamma_Left':
        # Left boundary (outer surface)
        val[:, 0, 0] = h_o[hour_idx]  # h value
        val[:, 0, 1] = t_o[hour_idx]   # T_inf value
    elif region_name == 'Gamma_Right':
        # Right boundary (inner surface)
        val[:, 0, 0] = h_i  # h value
        val[:, 0, 1] = t_i   # T_inf value
    
    return {'val': val}

lam_i = 0.32      # Thermal conductivity [W/(mK)]
c_wet = 2.59E03 # J/(kg*K)
rho_dry = 100.0 # kg/m^3
moist_cont = 50.0 # %
rho_wet = rho_dry + moist_cont/100.0*1000 # kg/m^3
D = lam_i/(c_wet * rho_wet) # m^2/s

materials = {
    'mat': ({'lam': lam_i, 'rho_cp': lam_i/D},),
    'bc': 'get_bc_values',
    'heat_loss': ({ 'h_bot': -h_o[len(h_o)-1], 'T_bot_inf': t_o[len(t_o)-1],
                    'h_top': -h_o[0], 'T_top_inf': t_o[0]},)
}

field_1 = {
    'name' : 'temperature',
    'dtype' : 'real',
    'shape' : (1,),
    'region' : 'Omega',
    'approx_order' : 1,
}

variable_1 = {
    'name' : 'T',
    'kind' : 'unknown field',
    'field' : 'temperature',
    'order' : 0,
    'history' : 1,
}
variable_2 = {
    'name' : 's',
    'kind' : 'test field',
    'field' : 'temperature',
    'dual' : 'T',
}

regions = {
    'Omega' : 'all',
    'Gamma_Left' : ('vertices in (x < 0.00001)', 'facet'),
    'Gamma_Right' : ('vertices in (x > %f)' % (d_ins - 0.00001), 'facet'),
}


functions = {
    'get_bc_values': (get_bc_values,),
}

t_i = 0.0         # Inner temperature [Â°C]

ebcs = {
    #'t1' : ('Gamma_Left', {'t.0' : 0.3}),
    #'t2' : ('Gamma_Right', {'t.0' : -0.3}),
    't2': ('Gamma_Right', {'T.0': t_i}),  # Constant temperature on right
}

ics = {
    'ic': ('Omega', {'T.0': 0.0}),
}

integral_1 = {
    'name' : 'i',
    'order' : 1,
}

#equations = {
#    'Temperature' :
#    """dw_dot.i.Omega( s, dT/dt )
#     + dw_laplace.i.Omega( m.D, s, T ) = 0"""
#}

#equations = {
#    'Heat': """dw_dot.i.Omega(mat.rho_cp, s, dT/dt)
#             + dw_laplace.i.Omega(mat.lam, s, T) = 0"""
#}


equations = {
    'Heat': """dw_dot.i.Omega(mat.rho_cp, s, dT/dt)
             + dw_laplace.i.Omega(mat.lam, s, T)
             = + dw_bc_newton.i.Gamma_Left(heat_loss.h_top, heat_loss.T_top_inf, s, T)
             """
}

solver_0 = {
    'name' : 'ls',
    'kind' : 'ls.scipy_direct',
    'use_presolve' : True,
}

solver_1 = {
    'name' : 'newton',
    'kind' : 'nls.newton',

    'i_max'      : 1,
    'eps_a'      : 1e-10,
    'eps_r'      : 1.0,
    'macheps'   : 1e-16,
    'lin_red'    : 1e-2, # Linear system error < (eps_a * lin_red).
    'ls_red'     : 0.1,
    'ls_red_warp' : 0.001,
    'ls_on'      : 1.1,
    'ls_min'     : 1e-5,
    'check'     : 0,
    'delta'     : 1e-6,
    'is_linear' : True,
}

t0 = 0.0
t1 = 0.1
dt = 10.0
n_step = int(3600 / dt)  # Number of time intervals in one hour

solver_2 = {
    'name' : 'ts',
    'kind' : 'ts.simple',

    't0'    : t0,
    't1'    : t1,
    'dt'    : None,
    #'n_step' : n_step, # has precedence over dt!
    'verbose' : 1,
}

options = {
    'nls' : 'newton',
    'ls' : 'ls',
    'ts' : 'ts',
    'save_times' : 'all',
    'output_dir': './output_snow',  # Directory to save the output
}
